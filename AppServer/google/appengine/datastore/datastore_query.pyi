# Stubs for google.appengine.datastore.datastore_query (Python 2)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from google.appengine.datastore import datastore_rpc
from typing import Any, Optional

# TODO type info

class _BaseComponent:
    def __eq__(self, other: Any): ...
    def __ne__(self, other: Any): ...

def make_filter(name: Any, op: Any, values: Any): ...

class _PropertyComponent(_BaseComponent):
    def _get_prop_names(self) -> None: ...

class FilterPredicate(_PropertyComponent):
    def __call__(self, entity: Any): ...
    def _apply(self, key_value_map: Any) -> None: ...
    def _prune(self, key_value_map: Any) -> None: ...
    def _to_pb(self) -> None: ...
    def _to_pbs(self): ...

class _SinglePropertyFilter(FilterPredicate):
    def _get_prop_name(self) -> None: ...
    def _apply_to_value(self, value: Any) -> None: ...
    def _get_prop_names(self): ...
    def _apply(self, value_map: Any): ...
    def _prune(self, value_map: Any): ...

class PropertyFilter(_SinglePropertyFilter):
    _OPERATORS: Any = ...
    _OPERATORS_INVERSE: Any = ...
    _OPERATORS_TO_PYTHON_OPERATOR: Any = ...
    _INEQUALITY_OPERATORS: Any = ...
    _INEQUALITY_OPERATORS_ENUM: Any = ...
    _UPPERBOUND_INEQUALITY_OPERATORS: Any = ...
    _filter: Any = ...
    def __init__(self, op: Any, value: Any) -> None: ...
    @property
    def op(self): ...
    @property
    def value(self): ...
    def __repr__(self): ...
    def _get_prop_name(self): ...
    _cmp_value: Any = ...
    _condition: Any = ...
    def _apply_to_value(self, value: Any): ...
    def _has_inequality(self): ...
    @classmethod
    def _from_pb(cls, filter_pb: Any): ...
    def _to_pb(self): ...
    def __getstate__(self) -> None: ...
    def __eq__(self, other: Any): ...

class _PropertyRangeFilter(_SinglePropertyFilter):
    _start_key_value: Any = ...
    _end_key_value: Any = ...
    _start: Any = ...
    _start_incl: Any = ...
    _end: Any = ...
    _end_incl: Any = ...
    def __init__(self, start: Optional[Any] = ..., start_incl: bool = ..., end: Optional[Any] = ..., end_incl: bool = ...) -> None: ...
    @classmethod
    def from_property_filter(cls, prop_filter: Any): ...
    def intersect(self, other: Any): ...
    def _get_start_key_value(self): ...
    def _get_end_key_value(self): ...
    def _apply_to_value(self, value: Any): ...
    def _get_prop_name(self): ...
    def _to_pbs(self): ...
    def __getstate__(self) -> None: ...
    def __eq__(self, other: Any): ...

class _PropertyExistsFilter(FilterPredicate):
    _names: Any = ...
    def __init__(self, names: Any) -> None: ...
    def _apply(self, value_map: Any): ...
    def _get_prop_names(self): ...
    def _prune(self, _: Any) -> None: ...
    def __getstate__(self) -> None: ...

class CorrelationFilter(FilterPredicate):
    _subfilter: Any = ...
    def __init__(self, subfilter: Any) -> None: ...
    @property
    def subfilter(self): ...
    def __repr__(self): ...
    def _apply(self, value_map: Any): ...
    def _apply_correlated(self, value_maps: Any): ...
    def _group_values(self, prop: Any, values: Any): ...
    def _get_prop_names(self): ...

class CompositeFilter(FilterPredicate):
    AND: str = ...
    _OPERATORS: Any = ...
    _op: Any = ...
    _filters: Any = ...
    def __init__(self, op: Any, filters: Any) -> None: ...
    @property
    def op(self): ...
    @property
    def filters(self): ...
    def __repr__(self): ...
    def _get_prop_names(self): ...
    def _apply(self, value_map: Any): ...
    def _prune(self, value_map: Any): ...
    def _to_pbs(self): ...
    def __eq__(self, other: Any): ...

class _IgnoreFilter(_SinglePropertyFilter):
    _keys: Any = ...
    def __init__(self, key_value_set: Any) -> None: ...
    def _get_prop_name(self): ...
    def _apply_to_value(self, value: Any): ...

class _DedupingFilter(_IgnoreFilter):
    def __init__(self, key_value_set: Optional[Any] = ...) -> None: ...
    def _apply_to_value(self, value: Any): ...

class Order(_PropertyComponent):
    def reversed(self, group_by: Optional[Any] = ...) -> None: ...
    def _key(self, lhs_value_map: Any) -> None: ...
    def _cmp(self, lhs_value_map: Any, rhs_value_map: Any) -> None: ...
    def _to_pb(self) -> None: ...
    def key_for_filter(self, filter_predicate: Any): ...
    def cmp_for_filter(self, filter_predicate: Any): ...
    def key(self, entity: Any, filter_predicate: Optional[Any] = ...): ...
    def cmp(self, lhs: Any, rhs: Any, filter_predicate: Optional[Any] = ...): ...

class _ReverseOrder(_BaseComponent):
    _obj: Any = ...
    def __init__(self, obj: Any) -> None: ...
    def __hash__(self): ...
    def __cmp__(self, other: Any): ...

class PropertyOrder(Order):
    ASCENDING: Any = ...
    DESCENDING: Any = ...
    _DIRECTIONS: Any = ...
    __order: Any = ...
    def __init__(self, prop: Any, direction: Any = ...) -> None: ...
    @property
    def prop(self): ...
    @property
    def direction(self): ...
    def __repr__(self): ...
    def reversed(self, group_by: Optional[Any] = ...): ...
    def _get_prop_names(self): ...
    def _key(self, lhs_value_map: Any): ...
    def _cmp(self, lhs_value_map: Any, rhs_value_map: Any): ...
    @classmethod
    def _from_pb(cls, order_pb: Any): ...
    def _to_pb(self): ...
    def __getstate__(self) -> None: ...

class CompositeOrder(Order):
    _orders: Any = ...
    def __init__(self, orders: Any) -> None: ...
    @property
    def orders(self): ...
    def __repr__(self): ...
    def reversed(self, group_by: Optional[Any] = ...): ...
    def _get_prop_names(self): ...
    def _key(self, lhs_value_map: Any): ...
    def _cmp(self, lhs_value_map: Any, rhs_value_map: Any): ...
    def size(self): ...
    def _to_pbs(self): ...
    def __eq__(self, other: Any): ...

class FetchOptions(datastore_rpc.Configuration):
    def produce_cursors(value: Any): ...
    def offset(value: Any): ...
    def batch_size(value: Any): ...

class QueryOptions(FetchOptions):
    ORDER_FIRST: Any = ...
    ANCESTOR_FIRST: Any = ...
    FILTER_FIRST: Any = ...
    _HINTS: Any = ...
    def keys_only(value: Any): ...
    def projection(value: Any): ...
    def limit(value: Any): ...
    def prefetch_size(value: Any): ...
    def start_cursor(value: Any): ...
    def end_cursor(value: Any): ...
    def hint(value: Any): ...

class Cursor(_BaseComponent):
    __compiled_cursor: Any = ...
    def __init__(self, _cursor_pb: Optional[Any] = ..., urlsafe: Optional[Any] = ...) -> None: ...
    def __repr__(self): ...
    def reversed(self): ...
    def to_bytes(self): ...
    @staticmethod
    def from_bytes(cursor: Any): ...
    @staticmethod
    def _bytes_to_cursor_pb(cursor: Any): ...
    def urlsafe(self): ...
    to_websafe_string: Any = ...
    @staticmethod
    def from_websafe_string(cursor: Any): ...
    @staticmethod
    def _urlsafe_to_bytes(cursor: Any): ...
    @staticmethod
    def _from_query_result(query_result: Any): ...
    def advance(self, offset: Any, query: Any, conn: Any): ...
    def _to_pb(self): ...

class _QueryKeyFilter(_BaseComponent):
    __ancestor: Any = ...
    __path: Any = ...
    __app: Any = ...
    __namespace: Any = ...
    __kind: Any = ...
    def __init__(self, app: Optional[Any] = ..., namespace: Optional[Any] = ..., kind: Optional[Any] = ..., ancestor: Optional[Any] = ...) -> None: ...
    @property
    def app(self): ...
    @property
    def namespace(self): ...
    @property
    def kind(self): ...
    @property
    def ancestor(self): ...
    def __call__(self, entity_or_reference: Any): ...
    def _to_pb(self): ...

class _BaseQuery(_BaseComponent):
    def run(self, conn: Any, query_options: Optional[Any] = ...): ...
    def run_async(self, conn: Any, query_options: Optional[Any] = ...) -> None: ...
    def __getstate__(self) -> None: ...

class Query(_BaseQuery):
    _key_filter: Any = ...
    _order: Any = ...
    _filter_predicate: Any = ...
    _group_by: Any = ...
    def __init__(self, app: Optional[Any] = ..., namespace: Optional[Any] = ..., kind: Optional[Any] = ..., ancestor: Optional[Any] = ..., filter_predicate: Optional[Any] = ..., group_by: Optional[Any] = ..., order: Optional[Any] = ...) -> None: ...
    @property
    def app(self): ...
    @property
    def namespace(self): ...
    @property
    def kind(self): ...
    @property
    def ancestor(self): ...
    @property
    def filter_predicate(self): ...
    @property
    def order(self): ...
    @property
    def group_by(self): ...
    def __repr__(self): ...
    def run_async(self, conn: Any, query_options: Optional[Any] = ...): ...
    @classmethod
    def _from_pb(cls, query_pb: Any): ...
    def _to_pb(self, conn: Any, query_options: Any): ...

def apply_query(query: Any, entities: Any): ...

class _AugmentedQuery(_BaseQuery):
    _query: Any = ...
    _max_filtered_count: Any = ...
    _in_memory_filter: Any = ...
    _in_memory_results: Any = ...
    def __init__(self, query: Any, in_memory_results: Optional[Any] = ..., in_memory_filter: Optional[Any] = ..., max_filtered_count: Optional[Any] = ...) -> None: ...
    def run_async(self, conn: Any, query_options: Optional[Any] = ...): ...

def inject_results(query: Any, updated_entities: Optional[Any] = ..., deleted_keys: Optional[Any] = ...): ...

class _BatchShared:
    __query: Any = ...
    __query_options: Any = ...
    __conn: Any = ...
    __augmented_query: Any = ...
    __was_first_result_processed: bool = ...
    def __init__(self, query: Any, query_options: Any, conn: Any, augmented_query: Optional[Any] = ...) -> None: ...
    @property
    def query(self): ...
    @property
    def query_options(self): ...
    @property
    def conn(self): ...
    @property
    def augmented_query(self): ...
    @property
    def keys_only(self): ...
    @property
    def compiled_query(self): ...
    @property
    def index_list(self): ...
    __keys_only: Any = ...
    __compiled_query: Any = ...
    __index_list: Any = ...
    def process_query_result_if_first(self, query_result: Any) -> None: ...

class Batch:
    @classmethod
    def create_async(cls, query: Any, query_options: Any, conn: Any, req: Any, start_cursor: Any): ...
    _batch_shared: Any = ...
    __start_cursor: Any = ...
    def __init__(self, batch_shared: Any, start_cursor: Any = ...) -> None: ...
    @property
    def query_options(self): ...
    @property
    def query(self): ...
    @property
    def results(self): ...
    @property
    def keys_only(self): ...
    @property
    def index_list(self): ...
    @property
    def start_cursor(self): ...
    @property
    def end_cursor(self): ...
    @property
    def skipped_results(self): ...
    @property
    def more_results(self): ...
    def next_batch(self, fetch_options: Optional[Any] = ...): ...
    def _compiled_query(self): ...
    def cursor(self, index: Any): ...
    def next_batch_async(self, fetch_options: Optional[Any] = ...): ...
    __datastore_cursor: Any = ...
    def _to_pb(self, fetch_options: Optional[Any] = ...): ...
    __more_results: Any = ...
    __end_cursor: Any = ...
    def _extend(self, next_batch: Any) -> None: ...
    def _make_query_result_rpc_call(self, name: Any, config: Any, req: Any): ...
    _need_index_header: str = ...
    _skipped_results: Any = ...
    __results: Any = ...
    def __query_result_hook(self, rpc: Any): ...
    def _end(self) -> None: ...
    def _make_next_batch(self, fetch_options: Any): ...
    def _process_results(self, results: Any): ...
    def __getstate__(self) -> None: ...

class _AugmentedBatch(Batch):
    @classmethod
    def create_async(cls, augmented_query: Any, query_options: Any, conn: Any, req: Any, in_memory_offset: Any, in_memory_limit: Any, start_cursor: Any): ...
    __in_memory_offset: Any = ...
    __in_memory_limit: Any = ...
    __next_index: Any = ...
    def __init__(self, batch_shared: Any, in_memory_offset: Optional[Any] = ..., in_memory_limit: Optional[Any] = ..., next_index: int = ..., start_cursor: Any = ...) -> None: ...
    @property
    def query(self): ...
    def cursor(self, index: Any) -> None: ...
    def _extend(self, next_batch: Any) -> None: ...
    def _process_results(self, results: Any): ...
    def _make_next_batch(self, fetch_options: Any): ...

class Batcher:
    ASYNC_ONLY: Any = ...
    AT_LEAST_OFFSET: int = ...
    AT_LEAST_ONE: Any = ...
    __next_batch: Any = ...
    __initial_offset: Any = ...
    __skipped_results: int = ...
    def __init__(self, query_options: Any, first_async_batch: Any) -> None: ...
    def next(self): ...
    def next_batch(self, min_batch_size: Any): ...
    def __getstate__(self) -> None: ...
    def __iter__(self): ...

class ResultsIterator:
    __batcher: Any = ...
    __current_batch: Any = ...
    __current_pos: int = ...
    def __init__(self, batcher: Any) -> None: ...
    def index_list(self): ...
    def cursor(self): ...
    def _ensure_current_batch(self): ...
    def _compiled_query(self): ...
    def next(self): ...
    def __iter__(self): ...
